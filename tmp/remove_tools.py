import re

def remove_system_prompt(content: str) -> str:
    # 替换<|SYSTEM_PROMPT|>****<|SYSTEM_PROMPT|>之间所有内容为空
    result = re.sub(r"<\|SYSTEM_PROMPT\|>.*?<\|SYSTEM_PROMPT\|>", "", content, flags=re.DOTALL|re.MULTILINE)
    # 移除多余的空行
    result = re.sub(r'\n\s*\n', '\n', result)
    return result.strip()

if __name__ == "__main__":
    print(remove_system_prompt("""<|SYSTEM_PROMPT|> 你是一个可以帮助用户分析学术论文的助手。 你可以在答案的结尾使用三个大于号 ">>>note_example" 帮用户记笔记。 <|SYSTEM_PROMPT|> <|SYSTEM_PROMPT|>我正在浏览以下的内容： # CSC4001 Software Engineering Assignment 1 Due – 23:59, 26th February, 2025 Aoyang Fang (aoyangfang@link.cuhk.edu.cn) **Note:** Late submission will have grade of 0 ## 1.1 Single Choice (10 points) Each question has only one correct answer. **(a) (5 points) Which of the following statements is correct?** A. Unit testing requires full integration with databases or external APIs to verify component behavior. B. The goal of integration testing is to validate that individual units of software work as expected and adhere to design specifications. C. System tests can skip environment validation because unit tests already covered it. D. Unit testing is a software testing technique that focuses on verifying individual components or units of code to ensure they function correctly. **(b) (5 points) Which of the following statement is correct?** A. Integration testing is crucial for verifying the interfaces between subsystems and ensuring that the entire system functions as expected when all parts are integrated B. Integration testing is unnecessary if unit tests pass for all components. C. System testing is a level of software testing where individual units or components of a software are combined and tested as a group. D. Functional testing guarantees 100% defect detection in complex systems. ## 1.2 Multiple Choice (10 points) Each question has more than one correct answer. **(a) (5 points) Which of the following statements are correct?** A. Whitebox testing is only applicable during unit testing. B. The goal of dividing inputs into equivalence classes is to reduce the design of unnecessary test cases by grouping inputs that are expected to behave similarly, thus improving test efficiency. C. Integration testing involves testing the interactions between different subsystems or modules within a software system. D. Boundary testing only needs to focus on edge cases where input values are at their minimum, maximum. **(b) (5 points) Which of the following statements are correct?** A. The primary goal of system testing is to verify that the entire system functions correctly and meets the defined requirements. B. Branch coverage is usually more practical than path coverage. C. Boundary testing only applies to numeric inputs, not to text or categorical data. D. System testing is a level of software testing where a complete and integrated software system is tested. 2. Coverage (40 points) Consider the following Python program: ```python def jump(nums): if len(nums) == 1: return 0 jumps = 0 maxReach = 0 end = 0 for i in range(len(nums) - 1): maxReach = max(maxReach, i + nums[i]) if i == end: jumps += 1 end = maxReach if end >= len(nums) - 1: break return jumps ``` (a) (20 points) For the given test suite: `jump([])` Please calculate the statement coverage (10 points) and branch coverage (10 points). For the statement coverage calculation, please count the number of basic blocks instead of statements. (b) (10 points) Please provide a test suite that contains at most two test cases and achieves 100% statement coverage. (c) (10 points) Please provide a test suite that contains at most 3 test cases and achieves 100% branch coverage. 3. Control flow graph (40 points) You are given the following three-address code (3AC): | Line | Code | |------|----------------| | 1 | a = input | | 2 | b = a + 5 | | 3 | c = b * 2 | A diagram showing a three-address code with lines numbered 4 to 13. The code includes assignment statements, conditional statements (`if`), and a `goto` statement. The code ends with a `return` statement. Below the code, there are two sections: (a) Identifying Basic Blocks, and (b) Constructing the Control Flow Graph (CFG). Section (a) has two sub-sections: a) identifying leaders and b) determining basic blocks. Section (b) describes constructing the CFG based on the identified basic blocks. There is no image to describe. <|SYSTEM_PROMPT|>我不懂"""))
